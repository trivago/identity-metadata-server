package main

import (
	"context"
	"errors"
	"fmt"
	"identity-metadata-server/internal/shared"
	"identity-metadata-server/internal/tokenprovider"
	"io"
	"net/http"
	"os"
	"strings"
	"sync"
	"time"

	"github.com/cespare/xxhash"
	jsoniter "github.com/json-iterator/go"
	"github.com/rs/zerolog/log"
	"github.com/spf13/viper"
)

type timedToken struct {
	token    string
	deadline time.Time
}

var (
	selfTokenCacheGuard = new(sync.Mutex)
	selfTokenCache      = make(map[uint64]timedToken)
)

// selfTokenHash generates a hash for the given scopes.
// This hash is used to cache the token for the given scopes.
func selfTokenHash(scopes []string) uint64 {
	scopeString := strings.Join(scopes, " ")

	h := xxhash.New()
	h.Write([]byte(scopeString))
	return h.Sum64()
}

// GetIdentityServerToken generates a new token for the given service account and scopes.
// This function is used to retrieve an identity token for the identity server.
func GetIdentityServerToken(scopes []string, ctx context.Context) (string, error) {
	hash := selfTokenHash(scopes)

	selfTokenCacheGuard.Lock()
	defer selfTokenCacheGuard.Unlock()

	if token, ok := selfTokenCache[hash]; ok {
		if time.Now().Before(token.deadline) {
			return token.token, nil
		}
		delete(selfTokenCache, hash)
	}

	scopes = shared.AssureIdentityScope(scopes)
	serviceAccount := viper.GetString("server.identity")

	tokenRequestBody, err := newTokenExchangeRequest(serviceAccount, scopes)
	if err != nil {
		return "", errors.Join(err, errors.New("failed to generate token exchange request body"))
	}

	tokenRequestToken, err := getTokenRequestToken(tokenRequestBody, ctx)
	if err != nil {
		return "", errors.Join(err, errors.New("failed to get token request token"))
	}

	// Return the actual token
	tokenLifeTime := time.Minute * 15

	gcpTokenProvider := tokenprovider.GcpTokenProvider{}
	iamToken, err := gcpTokenProvider.GetAccessToken(ctx, *tokenRequestToken, tokenLifeTime, scopes, serviceAccount)
	if err != nil {
		return "", errors.Join(err, errors.New("failed to get access token"))
	}

	// Cache the token for half the lifetime so that we don't
	// have to request a new token with every call.
	selfTokenCache[hash] = timedToken{
		token:    iamToken.AccessToken,
		deadline: time.Now().Add(tokenLifeTime / 2),
	}

	return iamToken.AccessToken, nil
}

// newTokenExchangeRequest generates a new token exchange request for the given service account and scopes.
// It uses the workload identity audience to create the request.
// The OIDC token is generated using the hostname of the machine and the given service account.
func newTokenExchangeRequest(serviceAccount string, scopes []string) (string, error) {
	// We need the hostname for IAM bindings to work.
	// As we also need the private key for "hijacking" the idenity-server, an
	// override is ok here. We also need this for integration tests.
	hostname := viper.GetString("server.hostname")
	if len(hostname) == 0 {
		var err error
		if hostname, err = os.Hostname(); err != nil {
			return "", errors.Join(err, errors.New("failed to get hostname"))
		}
	}

	workloadIdentityAudience := shared.GetWorkloadIdentityAudience(
		viper.GetString("server.workloadIdentity.projectNumber"),
		viper.GetString("server.workloadIdentity.poolName"),
		viper.GetString("server.workloadIdentity.providerName"))

	log.Debug().Str("identity", workloadIdentityAudience+"/"+hostname).Msg("Creating token exchange request")

	oidcToken, err := generateOIDCToken(serviceAccount, hostname, []string{workloadIdentityAudience}, time.Minute*15)
	if err != nil {
		return "", errors.Join(err, errors.New("failed to create OIDC token"))
	}

	// Exchange the OIDC token with a GCP access token
	tokenRequest := shared.TokenExchangeRequest{
		Audience:           workloadIdentityAudience,
		GrantType:          "urn:ietf:params:oauth:grant-type:token-exchange",
		RequestedTokenType: "urn:ietf:params:oauth:token-type:access_token",
		Scope:              strings.Join(scopes, " "),
		SubjectToken:       oidcToken,
		SubjectTokenType:   "urn:ietf:params:oauth:token-type:jwt",
	}

	return jsoniter.MarshalToString(tokenRequest)
}

// getTokenRequestToken makes a request to the token endpoint to get a token request token.
// It uses the tokenRequestBody generated by newTokenExchangeRequest.
// The return value of this function can be used with the GetAccessToken function from the GcpTokenProvider.
func getTokenRequestToken(tokenRequestBody string, ctx context.Context) (*shared.TokenExchangeResponse, error) {
	// See https://cloud.google.com/iam/docs/reference/sts/rest/v1/TopLevel/token
	tokenRequestTokenResponse, err := shared.HttpPOST(
		"https://"+shared.EndpointSTS+"/token", []byte(tokenRequestBody),
		map[string]string{
			"Content-Type": "application/json",
		}, nil, 2, ctx)

	if err != nil {
		return nil, errors.Join(err, errors.New("failed to call token endpoint"))
	}

	// If the response is not 200, we log the response and return nil
	if tokenRequestTokenResponse.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(tokenRequestTokenResponse.Body)
		log.Error().
			Int("status", tokenRequestTokenResponse.StatusCode).
			Str("content-type", tokenRequestTokenResponse.Header.Get("Content-Type")).
			Str("body", string(body)).
			Msg("Failed to get access token")
		return nil, fmt.Errorf("unexpected HTTP status: %v. Body: %s", tokenRequestTokenResponse.StatusCode, string(body))
	}

	tokenRequestToken := shared.TokenExchangeResponse{}
	err = jsoniter.NewDecoder(tokenRequestTokenResponse.Body).Decode(&tokenRequestToken)
	return &tokenRequestToken, err
}
